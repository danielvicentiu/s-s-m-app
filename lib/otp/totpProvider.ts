// lib/otp/totpProvider.ts
// TOTP (Time-based One-Time Password) provider
// Uses otpauth library for RFC 6238 compliance
// Secret encrypted with AES-256-GCM before storage

import crypto from 'crypto'
import { TOTP, Secret } from 'otpauth'
import type { OTPProvider, OTPChannel, OTPSendResult, OTPCheckResult } from './types'

const ALGORITHM = 'aes-256-gcm'
const KEY_LENGTH = 32
const ISSUER = 'SSM Platform'

// Get AES-256 key from env — falls back to first 32 chars of TWILIO_AUTH_TOKEN
function getEncryptionKey(): Buffer {
  const envKey = process.env.TOTP_ENCRYPTION_KEY
  if (envKey) {
    return Buffer.from(envKey.padEnd(KEY_LENGTH, '0').slice(0, KEY_LENGTH))
  }
  const twilioToken = process.env.TWILIO_AUTH_TOKEN || ''
  return Buffer.from(twilioToken.padEnd(KEY_LENGTH, '0').slice(0, KEY_LENGTH))
}

// Encrypt plaintext → "ivHex:tagHex:encryptedHex"
export function encryptSecret(plaintext: string): string {
  const key = getEncryptionKey()
  const iv = crypto.randomBytes(12)
  const cipher = crypto.createCipheriv(ALGORITHM, key, iv)
  const encrypted = Buffer.concat([
    cipher.update(plaintext, 'utf8'),
    cipher.final(),
  ])
  const tag = cipher.getAuthTag()
  return `${iv.toString('hex')}:${tag.toString('hex')}:${encrypted.toString('hex')}`
}

// Decrypt "ivHex:tagHex:encryptedHex" → plaintext
export function decryptSecret(ciphertext: string): string {
  const key = getEncryptionKey()
  const parts = ciphertext.split(':')
  if (parts.length !== 3) throw new Error('Invalid ciphertext format')
  const [ivHex, tagHex, encryptedHex] = parts
  const iv = Buffer.from(ivHex, 'hex')
  const tag = Buffer.from(tagHex, 'hex')
  const encrypted = Buffer.from(encryptedHex, 'hex')
  const decipher = crypto.createDecipheriv(ALGORITHM, key, iv)
  decipher.setAuthTag(tag)
  const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()])
  return decrypted.toString('utf8')
}

// Generate a new TOTP secret and return both raw (for storage encryption) and the otpauth URI
export function generateTOTPSecret(userLabel: string): {
  secretBase32: string
  uri: string
} {
  const secret = new Secret()
  const totp = new TOTP({
    issuer: ISSUER,
    label: userLabel,
    algorithm: 'SHA1',
    digits: 6,
    period: 30,
    secret,
  })

  return {
    secretBase32: secret.base32,
    uri: totp.toString(),
  }
}

// Verify a TOTP code using the stored encrypted secret
export function verifyTOTPCode(secretBase32: string, code: string): boolean {
  try {
    const secret = Secret.fromBase32(secretBase32)
    const totp = new TOTP({
      algorithm: 'SHA1',
      digits: 6,
      period: 30,
      secret,
    })
    // window: 1 allows ±30 sec drift
    const delta = totp.validate({ token: code, window: 1 })
    return delta !== null
  } catch {
    return false
  }
}

// TOTP provider — sendCode is a no-op (user reads from authenticator app)
export class TOTPProvider implements OTPProvider {
  async sendCode(_phone: string, _channel: OTPChannel): Promise<OTPSendResult> {
    // TOTP codes are generated by the authenticator app — nothing to send
    return { success: true }
  }

  async checkCode(_phone: string, code: string): Promise<OTPCheckResult> {
    // Verification is done in the API route with the stored encrypted secret
    // This method is a stub — real verification calls verifyTOTPCode directly
    if (!code || code.length !== 6 || !/^\d{6}$/.test(code)) {
      return { valid: false, error: 'Codul TOTP trebuie să aibă 6 cifre.' }
    }
    return { valid: true }
  }
}
